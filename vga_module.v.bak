
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module vga_module#(parameter N = 16)(

	//////////// CLOCK //////////
	input CLOCK_50,

	//////////// reset //////////
	input reset,

	//////////// GPIO //////////
	output reg r, 
	output reg g, 
	output reg b, 
	output wire hs, 
	output wire vs,

	input [N-1:0] data,
	output [N-1:0] addr,
	output rd, 
	output wr
);

//=======================================================
//  PARAMETER declarations
//=======================================================


//=======================================================
//  PORT declarations
//=======================================================


//=======================================================
//  REG/WIRE declarations
//=======================================================

/*
reg [N-1:0] addr;
reg rd, wr;

assign addr_bus = (vga_read) ? addr : {N{1'bz}};
assign rd_bus = (vga_read) ? rd : {N{1'bz}};
assign wr_bus = (vga_read) ? wr : {N{1'bz}};
*/

reg clk25; // 25MHz signal (clk divided by 2)
reg newframe;
reg newline;

reg [9:0] x;
reg [9:0] y;
wire valid;
reg [15:0] curr_char;

reg [7:0] xx;
reg [7:0] yy;

wire [6:0] counter;
wire [7:0] pixels; // Pixels making up one row of the character 
wire [6:0] ty;

//=======================================================
//  Structural coding
//=======================================================


// Character generator

chars chars_1(
  .char(curr_char[7:0]),
  .rownum(y[2:0]),
  .pixels(pixels)
  ); 

assign hs = x < (640 + 16) || x >= (640 + 16 + 96);
assign vs = y < (480 + 10) || y >= (480 + 10 + 2);
assign valid = (x < 640) && (y < 480);
assign counter = (valid)?(x >> 3) + (y >> 3)*80 :0;   //<<<< MULTIPLICATION!!!
assign ty = y >> 3;

reg [3:0]count_read;
reg mem_read;

always @(posedge CLOCK_50) begin
	newframe <= 0;
	newline <= 0;
	if (reset) begin
		x <= 10'b0;
		y <= 10'b0;
		clk25 <= 1'b0;
		newframe <= 1;
		newline <= 1;
	end 
	else begin
		clk25 <= ~clk25;
		if (clk25 == 1'b1) begin
			if (x < 10'd799) begin
				x <= x + 1'b1;
			end 
			else begin
				x <= 10'b0;
				newline <= 1;
				if (y < 10'd524) begin
					y <= y + 1'b1;
				end 
				else begin
					y <= 10'b0;
					newframe <= 1;
				end
			end
			if (mem_read) begin
				//if ((y & 7) == 0) begin
					curr_char <= data;//48+ty[2:0]; //data; //48 + counter[2:0];
					rd <= 1'bz;
					wr <= 1'bz;
					mem_read <= 0;
				//end
			end
		end 
		else begin
			// this is the other cycle when we divide 50MHz
			if (x >= 640) begin
				if (!mem_read) begin
					if ((x >= 640) && (y >= 480)) begin
						// when we start the vertical blanking, we need to fetch in advance the first character (0, 0)
						rd <= 1;
						wr <= 0;
						addr <= 0;
						mem_read <= 1;
					end
					else if ((x >= 640) && ((y & 7) < 7)) begin
						// when we start the horizontal blanking, and still displaying character in the current line,
						// we need to fetch in advance the first character in the current line (0, y)
						rd <= 1;
						wr <= 0;
						addr <= ((y >> 3) )*80;
						mem_read <= 1;
					end
					else if ((x >= 640) && ((y & 7) == 7)) begin
						// when we start the horizontal blanking, and we need to go to the next line, 
						// we need to fetch in advance the first character in next line (0, y+1)
						rd <= 1;
						wr <= 0;
						addr <= ((y >> 3) + 1)*80;
						mem_read <= 1;
					end
				end
			end // if (!valid)
			// from this moment on, x and y are valid
			else if (x < 640 && !mem_read) begin
				if ((x & 7) == 7) begin
					// when we are finishing current character, we need to fetch in advance the next character (x+1, y)
					// at the last pixel of the current character, let's fetch next
					rd <= 1;
					wr <= 0;
					addr <= (x >> 3) + (y >> 3)*80 + 1;
					mem_read <= 1;
				end
			end 
			 
		end
	end
	
	if (valid) begin
		r <= pixels[7 - (x & 7)] ? !curr_char[5+8] : curr_char[2+8];
		g <= pixels[7 - (x & 7)] ? !curr_char[4+8] : curr_char[1+8];
		b <= pixels[7 - (x & 7)] ? !curr_char[3+8] : curr_char[0+8];
	end 
	else begin
		// blanking -> no pixels
		r <= 0;
		g <= 0;
		b <= 0;
	end
end

initial begin
		x <= 10'b0;
		y <= 10'b0;
		clk25 <= 1'b0;
		newframe <= 1;
		newline <= 1;
end

endmodule

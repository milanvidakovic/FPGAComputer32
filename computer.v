`define GRAPHICS

//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================
`timescale 1ns / 10ps
module computer(

	//////////// CLOCK //////////
	CLOCK_50,

	//////////// LED //////////
	LED,

	//////////// KEY //////////
	KEY,

	//////////// SW //////////
	SW,

	//////////// GPIO_0, GPIO_0 connect to GPIO Default //////////
	gpio0,
	gpio0_IN,

	//////////// GPIO_1, GPIO_1 connect to GPIO Default //////////
	gpio1,
	gpio1_IN,

	/* SDRAM INTERFACE */
	sdram_ba_pad_o,
	sdram_a_pad_o,
	sdram_dq_pad_io,
	sdram_dqm_pad_o,
	sdram_cas_pad_o,
	sdram_ras_pad_o,
	sdram_we_pad_o,
	sdram_cs_n_pad_o,
	sdram_cke_pad_o,
	sdram_clk_pad_o

);

//=======================================================
//  PARAMETER declarations
//=======================================================


//=======================================================
//  PORT declarations
//=======================================================

//////////// CLOCK //////////
input 		          		CLOCK_50;

//////////// LED //////////
output		     [7:0]		LED;

//////////// KEY //////////
input 		     [1:0]		KEY;

//////////// SW //////////
input 		     [3:0]		SW;

//////////// GPIO_0, GPIO_0 connect to GPIO Default //////////
inout 		    [33:0]		gpio0;
input 		     [1:0]		gpio0_IN;

//////////// GPIO_1, GPIO_1 connect to GPIO Default //////////
inout 		    [33:0]		gpio1;
input 		     [1:0]		gpio1_IN;

  /* SDRAM INTERFACE */
output [1:0]  sdram_ba_pad_o;
output [12:0] sdram_a_pad_o;
inout  [15:0] sdram_dq_pad_io;
output [1:0]  sdram_dqm_pad_o;
output        sdram_cas_pad_o;
output        sdram_ras_pad_o;
output        sdram_we_pad_o;
output        sdram_cs_n_pad_o;
output        sdram_cke_pad_o;
output        sdram_clk_pad_o;


//=======================================================
//  Constants
//=======================================================

localparam IRQ_TIMER = 0;
localparam IRQ_UART  = 1;
localparam IRQ_PS2   = 2;
localparam N = 6'd32;

//=======================================================
//  Structural coding
//=======================================================
// address bus, data bus
wire [31:0] addr, addr2;
wire [15:0] data, data2;
wire [15:0] data_to_write;
// memory read signal
reg rd, rd2;
// memory write signal
reg wr, wr2;

// ###################
// Video VGA text instance 
// ###################

wire r, g, b, hs, vs;
wire vgaoe = 1'b1;

assign gpio0[3] = vgaoe ? r  : 1'bZ ;
assign gpio0[1] = vgaoe ? g  : 1'bZ ;
assign gpio0[0] = vgaoe ? b  : 1'bZ ;
assign gpio0[5] = vgaoe ? hs : 1'bZ ;
assign gpio0[7] = vgaoe ? vs : 1'bZ ;

reg [1:0]vga_mode;
reg  inverse;
//wire v0, v1;
//assign v0 = (vga_mode == 2'b00);
//assign v1 = (vga_mode == 2'b01);

vga_module #(.N(N))vga0(
	vga_mode,
	
	//////////// CLOCK //////////
	clk100,

	//////////// RESET KEY //////////
	~KEY[0],

	//////////// GPIO //////////
	r, 
	g, 
	b, 
	hs, 
	vs,
	
	data2,
	addr2,
	rd2, 
	wr2,
	inverse
);

`ifdef GRAPHICS
vga_320x240 vga1 (
	vga_mode,
	
	//////////// CLOCK //////////
	clk100,

	//////////// RESET KEY //////////
	~KEY[0],

	//////////// GPIO //////////
	r, 
	g, 
	b, 
	hs, 
	vs,
	
	data2,
	addr2,
	rd2, 
	wr2
);
`endif

// ####################################################################################################################
// RAM instance (dual port RAM; one port is connected to the CPU, while the other is connected to the video subsystem)
// ####################################################################################################################
RAM ram(
	clk100,
	data,
	addr,
	rd, wr,
	data_to_write,
	
	data2,
	addr2,
	rd2
);


// ####################################
// PS/2 keyboard instance
// ####################################
wire [7:0] ps2_data;
wire ps2_received;
reg [7:0] ps2_data_r;

ps2_read ps2(
  clk100,
  ~KEY[0],
  gpio0[31], 		// Input pin - PS/2 data line
  gpio0[33], 		// Input pin - PS/2 clock line
  ps2_data,  		// here we will receive a character
  ps2_received    // if something came from serial, this goes high
);

// ####################################
// UART receiver instance
// ####################################
wire [7:0] rx_data;
wire rx_received;
reg [7:0] rx_data_r;

rx_serial rsr(
  clk100,
  ~KEY[0],
  gpio0[27], 		// Input pin - receive line
  rx_data,  		// here we will receive a character
  rx_received    	// if something came from serial, this goes high
);

// ####################################
// UART transmitter instance
// ####################################
wire [7:0] tx_data;
wire tx_send;
wire tx_busy;

tx_serial tsr(
  clk100,
  ~KEY[0],
  tx_data, 		// Character to output
  tx_send,		// High = request a send
  gpio0[25],	// Output pin
  tx_busy		// High while character is being output
);

// ########################################
// IRQs 
// ########################################

reg cpu_reset = 1'b1;
reg [31:0] reset_counter;

// IRQ signals
wire [15:0] irq;
//reg [7:0] fakeLED;

always @ (posedge clk100) begin
	if (~KEY[0]) begin
		irq <= 0;
		reset_counter <= 32'd0;
		cpu_reset <= 1'b1;
	end
	if (reset_counter == 32'd200000000) begin
		cpu_reset <= 1'b0;
	end
	else
		reset_counter <= reset_counter + 1'b1;
	
	// ############################### IRQ2 - PS/2 keyboard #############################
	if (ps2_received) begin
		ps2_data_r <= ps2_data;
		// if we have received a byte from the keyboard, we will trigger the IRQ#2
		irq[IRQ_PS2] <= 1'b1;
	end
	else 
	begin
		irq[IRQ_PS2] <= 1'b0;
	end
	// ############################### IRQ1 - UART #############################
	if (rx_received) begin
		rx_data_r <= rx_data;
		// if we have received a byte from the UART, we will trigger the IRQ#1
		irq[IRQ_UART] <= 1'b1;
	end
	else 
	begin
		irq[IRQ_UART] <= 1'b0;
	end
end

// ####################################
// CPU instance
// ####################################
cpu cpu0 (
  .clk         (clk100),
  .rst         (cpu_reset),

  .rd_enable_o (rd_enable),
  .wr_enable_o (wr_enable),
  .busy_i      (busy),
  .rd_ready_i  (rd_ready),
  .rd_data_i   (rd_data),
  .wr_data_o   (wr_data),
  .addr_o      (addr),

  .LED         (LED),
  .rd          (rd),
  .wr          (wr),
  .data_i      (data),
  .data_to_write_o(data_to_write),
  
  .rx_data    (rx_data_r),  // UART RX data
  .tx_send    (tx_send),    // UART TX send signal
  .tx_busy    (tx_busy),    // UART TX busy signal
  .tx_data    (tx_data),    // UART TX data
  .vga_mode   (vga_mode),	 // VGA mode: 0-text; 1-320x240
  .inverse    (inverse),	 // inverse colors on VGA text mode
  .ps2_data   (ps2_data_r), // keyboard data
  
  .irq_i      (irq)

);


// ########################################
// SDRAM stuff 
// ########################################
wire	[15:0] wr_data;
wire         wr_enable;

wire	[15:0] rd_data;
wire         rd_enable;

wire         clk100;
wire         rd_ready;
wire         busy;

/* PLL */
pll plli (
  .inclk0    (CLOCK_50),
  .c0        (clk100),
  .c1        (),
  .c2        (),
  .areset    (~KEY[0])
);

assign sdram_clk_pad_o = clk100;

/* SDRam */
sdram_controller sdram_controlleri (
    /* HOST INTERFACE */
    .wr_addr(addr),
    .wr_data(wr_data),
    .wr_enable(wr_enable),

    .rd_addr(addr),
    .rd_data(rd_data),
    .rd_ready(rd_ready),
    .rd_enable(rd_enable),

    .busy(busy), .rst_n(KEY[0]), .clk(clk100),

    /* SDRAM SIDE */
    .addr          (sdram_a_pad_o),
    .bank_addr     (sdram_ba_pad_o),
    .data          (sdram_dq_pad_io),
    .clock_enable  (sdram_cke_pad_o),
    .cs_n          (sdram_cs_n_pad_o),
    .ras_n         (sdram_ras_pad_o),
    .cas_n         (sdram_cas_pad_o),
    .we_n          (sdram_we_pad_o),
    .data_mask_low (sdram_dqm_pad_o[0]),
    .data_mask_high(sdram_dqm_pad_o[1])
);

initial begin
	vga_mode <= 2'b00; // text mode
end

endmodule


//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module vga_320x240#(parameter N = 16)(
	input wire [1:0] vga_mode,
	//////////// CLOCK //////////
	input clk,
	input clk_50,
	input clk_25,

	//////////// reset //////////
	input reset,

	//////////// GPIO //////////
	output wire rr, 
	output wire rg, 
	output wire rb, 
	output wire hs, 
	output wire vs,

	output wire rrs, 
	output wire rgs, 
	output wire rbs, 

	input [N-1:0] data,
	output [N-1:0] raddr,
	output rrd, 
	output rwr
);

//=======================================================
//  PARAMETER declarations
//=======================================================

localparam VIDEO_MEM_ADDR = 1024/2;
localparam IN_LINE                       = 10;
localparam H_BLANK                       = 20;
localparam V_BLANK                       = 30;
localparam READ_SPRITES                  = 40;
localparam READ_SPRITE_X                 = 50;
localparam READ_SPRITE_Y                 = 60;
localparam READ_SPRITE_TRANSPARENT_COLOR = 70;
localparam READ_SPRITE_DATA              = 80;
localparam SCAN_IDLE                     = 90;

localparam SPRITE_DEF_ADDR					  = 128;
localparam SPRITE_NUM                    = 4;

//=======================================================
//  PORT declarations
//=======================================================


//=======================================================
//  REG/WIRE declarations
//=======================================================

reg clk25; // 25MHz signal (clk divided by 2)
reg clk50;

reg [9:0] x;
reg [9:0] y;
wire valid;
reg [15:0] curr_char;

reg [9:0] xx;
reg [9:0] yy;

wire [15:0] pixels; // Pixels making up one row of the word containing four pixels

assign valid = (x < 640) && (y < 480);
assign xx = x >> 1;
assign yy = y >> 1;

reg r, g, b, rs, gs, bs;
reg [N-1:0] addr;
reg rd; 
reg wr;

wire enable;
assign enable = vga_mode == 1;

assign raddr = enable ? addr : {N{1'bZ}};
assign rrd = enable ? rd : 1'bZ;
assign rwr = enable ? wr : 1'bZ;

assign hs = enable ? x < (640 + 16) || x >= (640 + 16 + 96) : 1'bZ;
assign vs = enable ? y < (480 + 10) || y >= (480 + 10 + 2)  : 1'bZ;
assign rr = enable ? r : 1'bZ;
assign rg = enable ? g : 1'bZ;
assign rb = enable ? b : 1'bZ;

assign rrs = enable ? rs : 1'bZ;
assign rgs = enable ? gs : 1'bZ;
assign rbs = enable ? bs : 1'bZ;

reg [3:0]count_read;
reg mem_read;
reg[7:0] state;

integer i = 0;
reg sprite_found;
reg [4:0] sprite_counter;

// Declare the sprite local memory
reg [63:0] sprite_pixels[0:SPRITE_NUM-1][0:15]; // 64x16 bits == 16x16 pixels for each sprite (SPRITE_NUM sprites supported)
reg [15:0] sprite_addr [0:SPRITE_NUM-1]; // addresses of all sprites
reg [15:0] sprite_x [0:SPRITE_NUM-1]; // x coordinate of all sprites
reg [15:0] sprite_y [0:SPRITE_NUM-1]; // y coordinate of all sprites
reg [3:0] sprite_transparent_color[0:SPRITE_NUM-1]; // transparent color for a sprite
reg [15:0] line_counter; // counter of lines of bytes to be fetched from the main memory into the sprite_pixels
reg [15:0] word_counter;  // counter of words within one row of sprite_pixels

always @(posedge clk) begin
	if (reset) begin
		clk50 <= 1'b0;
	end 
	clk50 <= ~clk50;
end

always @(posedge clk_50) begin
	case (state) 
		IN_LINE, H_BLANK: begin
			if (mem_read) begin
				pixels <= data;
				rd <= 1'b0;
				wr <= 1'b0;
				mem_read <= 1'b0;
			end
		end
		V_BLANK: begin
			pixels <= data;
			state <= SCAN_IDLE;
			rd <= 1'b0;
			wr <= 1'b0;
			mem_read <= 1'b0;
		end
	endcase
			
	if (reset) begin
		x <= 10'b0;
		y <= 10'b0;
		clk25 <= 1'b0;
		state <= IN_LINE;
		for (i = 0; i < SPRITE_NUM; i = i + 1) 
			sprite_addr[i] <= 16'd0;
		sprite_found = 1'b0;
	end 
	else begin
		clk25 <= ~clk25;
		if (clk25 == 1'b1) begin
			if (x < 10'd799) begin
				x <= x + 1'b1;
			end 
			else begin
				x <= 10'b0;
				state <= IN_LINE;
				if (y < 10'd524) begin
					y <= y + 1'b1;
				end 
				else begin
					y <= 10'b0;
					sprite_found = 1'b0;
				end
			end
			case (state) 
			READ_SPRITES: begin
				sprite_addr[sprite_counter] <= data;
				state <= READ_SPRITE_X;
				rd <= 1'b1;
				wr <= 1'b0;
				mem_read <= 1'b1;
				addr <= ((SPRITE_DEF_ADDR + 2) + (sprite_counter << 3)) >> 1;    // read x coordinate of the first sprite
			end
			READ_SPRITE_X: begin
				sprite_x[sprite_counter] <= data;
				state <= READ_SPRITE_Y;
				rd <= 1'b1;
				wr <= 1'b0;
				mem_read <= 1'b1;
				addr <= ((SPRITE_DEF_ADDR + 4) + (sprite_counter << 3)) >> 1;    // read y coordinate of the first sprite
			end
			READ_SPRITE_Y: begin
				sprite_y[sprite_counter] <= data;
				state <= READ_SPRITE_TRANSPARENT_COLOR;
				rd <= 1'b1;
				wr <= 1'b0;
				mem_read <= 1'b1;
				addr <= ((SPRITE_DEF_ADDR + 6) + (sprite_counter << 3)) >> 1;    // read transparent color of the first sprite
			end
			READ_SPRITE_TRANSPARENT_COLOR: begin
				sprite_transparent_color[sprite_counter] <= data[3:0];
				state <= READ_SPRITE_DATA;
				rd <= 1'b1;
				wr <= 1'b0;
				mem_read <= 1'b1;
				line_counter <= 16'b0;
				word_counter <= 4'b0;
				addr <= sprite_addr[sprite_counter] >> 1;    // read sprite definition bytes
			end
			READ_SPRITE_DATA: begin
				if (line_counter < 16) begin
					case (word_counter) 
					0:	sprite_pixels[sprite_counter][line_counter][63:48] <= data;
					1:	sprite_pixels[sprite_counter][line_counter][47:32] <= data;
					2:	sprite_pixels[sprite_counter][line_counter][31:16] <= data;
					3:	sprite_pixels[sprite_counter][line_counter][15:0]  <= data;
					endcase
					state <= READ_SPRITE_DATA;
					rd <= 1'b1;
					wr <= 1'b0;
					mem_read <= 1'b1;
					if (word_counter < 3) begin
						word_counter = word_counter + 1'b1;
					end
					else begin
						word_counter = 1'b0;
						line_counter = line_counter + 1'b1;
					end
					addr <= (sprite_addr[sprite_counter] + ((word_counter + (line_counter << 2)) << 1) ) >> 1;    // read sprite definition bytes
				end
				else 
				begin
					if (sprite_counter < SPRITE_NUM) begin
						sprite_counter <= sprite_counter + 1'b1;
						state <= READ_SPRITES;
						rd <= 1'b1;
						wr <= 1'b0;
						mem_read <= 1'b1;
						addr <= (SPRITE_DEF_ADDR + ((sprite_counter + 1'b1) << 3)) >> 1;    // read next sprite definition address
					end
					else begin
						sprite_counter <= 4'b0;
						rd <= 1'b1;
						wr <= 1'b0;
						mem_read <= 1'b1;
						addr <= VIDEO_MEM_ADDR + 0;
						state <= V_BLANK;
					end
				end
			end
			endcase
		end 
		else begin
			// this is the other cycle when we divide 50MHz
			if ((x >= 640) && (y == 479) && (state == IN_LINE)) begin
					// During the vertical blanking, we have 44 lines available to read sprite data (more than 300 16-bit words of sprite data), and then we will read pixels at (0, 0)
					state <= READ_SPRITES;
					sprite_counter <= 4'b0;
					rd <= 1'b1;
					wr <= 1'b0;
					mem_read <= 1'b1;
					addr <= SPRITE_DEF_ADDR >> 1;    // read the first sprite definition address
				end
			else if ((x == 640) && (y < 479) && (state == IN_LINE)) begin
					// when we start the horizontal blanking, and we need to go to the next line, 
					// we need to fetch in advance the first word in next line (0, y+1)
					state <= H_BLANK;
					rd <= 1'b1;
					wr <= 1'b0;
					mem_read <= 1'b1;
					if ((y & 1) == 1) begin
						addr <= VIDEO_MEM_ADDR + ((yy + 1) * 80);
					end
					else begin
						addr <= VIDEO_MEM_ADDR + ((yy) * 80);
					end
			end
			// from this moment on, x and y are valid
			else if ((x < 640) && (y < 480)) begin 
				state <= IN_LINE;
				if ((x & 7) == 7)  begin
					// when we are finishing current word, containing four pixels, we need to fetch in advance next four pixels at (x+1, y)
					rd <= 1'b1;
					wr <= 1'b0;
					addr <= VIDEO_MEM_ADDR + ((xx >> 2) + (yy * 80) + 1);
					mem_read <= 1'b1;
				end
			end 
			 
		end
	end
	
	if (valid) begin
		for (i = 0; i < SPRITE_NUM; i = i+1) begin
			if ((sprite_addr[i] != 16'b0) && (xx >= sprite_x[i]) && (xx < (sprite_x[i] + 16)) && (yy >= sprite_y[i]) && (yy < (sprite_y[i] + 16))) begin
				sprite_found = 1'b1;
				if (
					sprite_pixels[i][yy - sprite_y[i]][60-(((xx - sprite_x[i]) << 2) ) + 0] != sprite_transparent_color[i][0] ||
					sprite_pixels[i][yy - sprite_y[i]][60-(((xx - sprite_x[i]) << 2) ) + 1] != sprite_transparent_color[i][1] ||
					sprite_pixels[i][yy - sprite_y[i]][60-(((xx - sprite_x[i]) << 2) ) + 2] != sprite_transparent_color[i][2]
				) begin
					b <= sprite_pixels[i][yy - sprite_y[i]][60-(((xx - sprite_x[i]) << 2) ) + 0] == 1'b1;
					g <= sprite_pixels[i][yy - sprite_y[i]][60-(((xx - sprite_x[i]) << 2) ) + 1] == 1'b1;
					r <= sprite_pixels[i][yy - sprite_y[i]][60-(((xx - sprite_x[i]) << 2) ) + 2] == 1'b1;

					bs <= sprite_pixels[i][yy - sprite_y[i]][60-(((xx - sprite_x[i]) << 2) ) + 3] == 1'b1;
					gs <= sprite_pixels[i][yy - sprite_y[i]][60-(((xx - sprite_x[i]) << 2) ) + 3] == 1'b1;
					rs <= sprite_pixels[i][yy - sprite_y[i]][60-(((xx - sprite_x[i]) << 2) ) + 3] == 1'b1;
				end 
				else begin
					b <= pixels[12 - ((xx & 3) << 2) + 0] == 1'b1;
					g <= pixels[12 - ((xx & 3) << 2) + 1] == 1'b1;
					r <= pixels[12 - ((xx & 3) << 2) + 2] == 1'b1;

					bs <= pixels[12 - ((xx & 3) << 2) + 3] == 1'b1;
					gs <= pixels[12 - ((xx & 3) << 2) + 3] == 1'b1;
					rs <= pixels[12 - ((xx & 3) << 2) + 3] == 1'b1;
				end
			end 
		end
		if (!sprite_found) begin
			b <= pixels[12 - ((xx & 3) << 2) + 0] == 1'b1;
			g <= pixels[12 - ((xx & 3) << 2) + 1] == 1'b1;
			r <= pixels[12 - ((xx & 3) << 2) + 2] == 1'b1;

			bs <= pixels[12 - ((xx & 3) << 2) + 3] == 1'b1;
			gs <= pixels[12 - ((xx & 3) << 2) + 3] == 1'b1;
			rs <= pixels[12 - ((xx & 3) << 2) + 3] == 1'b1;
		end
		else begin
			sprite_found = 1'b0;
		end
	end
	else begin
		// blanking -> no pixels
		r <= 1'b0;
		g <= 1'b0;
		b <= 1'b0;

		rs <= 1'b0;
		gs <= 1'b0;
		bs <= 1'b0;
	end
end

initial begin
		x <= 10'b0;
		y <= 10'b0;
		clk25 <= 1'b0;
		clk50 <= 1'b0;
		state <= IN_LINE;
		for (i = 0; i < SPRITE_NUM; i = i + 1) 
			sprite_addr[i] <= 16'd0;
		sprite_found = 1'b0;
end

endmodule

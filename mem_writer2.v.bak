
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module mem_writer#(parameter N = 32)(
	
	input wire enable,

	//////////// CLOCK //////////
	input clk,

	//////////// reset //////////
	input rst_n,

	//////////// GPIO //////////
	output reg rr, 
	output reg rg, 
	output reg rb, 
	output wire hs, 
	output wire vs,

  output   reg     rd_enable_o,
  output   reg     wr_enable_o,
  input         busy_i,
  input         rd_ready_i,
  input  [15:0] rd_data_i,
  output reg [15:0] wr_data_o,
  output reg [ADDR_WIDTH-1:0] addr_o,

  output [7:0]  leds_o
);

//=======================================================
//  PARAMETER declarations
//=======================================================

localparam VIDEO_MEM_ADDR = 4096/2, ADDR_WIDTH    = 24;

localparam  INIT    = 4'b0000,
            WR      = 4'b0001,
            WR_WAIT = 4'b0010,
            WR_INC  = 4'b1000,
            RD      = 4'b0100,
            RD_WAIT = 4'b0101,
            RD_INC  = 4'b1001;
localparam 	IN_LINE = 1, 
				V_BLANK = 2,
				H_BLANK = 3,
				WORD_READ = 4;

//=======================================================
//  REG/WIRE declarations
//=======================================================

reg clk50; // 50MHz signal (clk100 divided by 2)
reg clk25; // 25MHz signal (clk50 divided by 2)

reg r, g, b;
reg rd; 
reg wr;

reg [9:0] x;
reg [9:0] y;
wire valid;
reg [15:0] curr_char;

wire [7:0] pixels; // Pixels making up one row of the character 

//=======================================================
//  Structural coding
//=======================================================

// Character generator

chars chars_1(
  .char(curr_char[7:0]),
  .rownum(y[2:0]),
  .pixels(pixels)
  ); 

assign hs = enable ? x < (640 + 16) || x >= (640 + 16 + 96) : 1'bZ;
assign vs = enable ? y < (480 + 10) || y >= (480 + 10 + 2)  : 1'bZ;
assign rr = enable ? r : 1'bZ;
assign rg = enable ? g : 1'bZ;
assign rb = enable ? b : 1'bZ;

assign raddr = enable ? addr_o : {N{1'bZ}};
assign rd_enable = enable ? rd_enable_o : 1'bZ;
assign wr_enable = enable ? wr_enable_o : 1'bZ;

assign valid = (x < 640) && (y < 480);

// ###############################################  VALIDATOR
//assign leds_o = addr_o[7:0];

reg	[15:0] rd_data_r, wr_data_r;

/* Counter to wait until sdram init cycle is complete.  */
reg     [ 5:0] init_cnt;

reg	[ 3:0] next;
reg	[ 3:0] state;
reg [3:0] render_state;


assign init_wait = |init_cnt;

always @ (posedge clk)
if (rst_n) begin
  init_cnt <= 6'b11_1111;
end
else if (init_wait) begin
  init_cnt <= init_cnt - 1'b1;
end


/* Validator state machine */

always @ (posedge clk)
begin
if (rst_n) begin
  clk50 <= 0;
end
else
	clk50 <= ~clk50;

 next = state;
 case (state)
  INIT:
    if (~init_wait) begin
      next = WR;
		addr_o <= VIDEO_MEM_ADDR;
		wr_data_r <= 16'd48;
	end
  WR: begin
    wr_data_o <= wr_data_r; //addr_o[15:0];//16'd3333;
    wr_enable_o <= 1'b1;
    if (busy_i)
      next = WR_WAIT;
  end
  WR_WAIT: begin
    wr_enable_o <= 1'b0;
    if (~busy_i)
      next = WR_INC;
  end
  WR_INC: begin
    addr_o <= addr_o + 1'b1;
	 wr_data_r <= wr_data_r + 1;
	 
	 if (wr_data_r == 127)
		wr_data_r <= 48;
		
    if (addr_o == ((VIDEO_MEM_ADDR + 80*60)-1)) begin /* We have reached the end of the video frame buffer -> go to RD */
      next = RD;
		addr_o <= VIDEO_MEM_ADDR;
		wr_data_r <= 48;
    end
	 else
      next = WR;
  end
  // START READING FRAME BUFFER
  RD: begin
    rd_enable_o <= 1'b1;
    if (busy_i)
      next = RD_WAIT;
  end
  RD_WAIT: begin
    rd_enable_o <= 1'b0;
    if (rd_ready_i) begin
		rd_data_r <= rd_data_i;
		next = RD_INC;
	 end
  end
  RD_INC: begin
	if (valid && ((x & 7) == 0) && (render_state != WORD_READ)) begin
		render_state <= WORD_READ;
	end
	if (valid) begin
		if (((x & 7) == 1) && (render_state == WORD_READ)) begin
			// when we are starting current character, we need to fetch in advance the next character (x+1, y)
			// at the last pixel of the current character, let's fetch next
			addr_o <= VIDEO_MEM_ADDR + ((x >> 3) + (y >> 3)*80 + 1);
			next = RD;
			render_state <= IN_LINE;
		end
	end
	else if (x == 640) begin
		if ((y < 479) && ((y & 7) < 7) && (render_state == IN_LINE)) begin
			// when we start the horizontal blanking, and still displaying character in the current line,
			// we need to fetch in advance the first character in the current line (0, y)
			addr_o <= VIDEO_MEM_ADDR + ((y >> 3)*80);
			next = RD;
			render_state <= H_BLANK;
		end
		else if ((y < 479) && ((y & 7) == 7) && (render_state == IN_LINE)) begin
			// when we start the horizontal blanking, and we need to go to the next line, 
			// we need to fetch in advance the first character in next line (0, y+1)
			addr_o <= VIDEO_MEM_ADDR + (((y >> 3) + 1)*80);
			next = RD;
			render_state <= H_BLANK;
		end
		else if ((y == 479) && ((render_state == IN_LINE))) begin
			// when we start the vertical blanking, we need to fetch in advance the first character (0, 0)
			addr_o <= VIDEO_MEM_ADDR + 0;
			next = RD;
			render_state <= V_BLANK;
		end
	end
  end
  endcase
 
end

always @ (posedge clk)
if (rst_n)
  state <= INIT;
else
  state <= next;

always @(posedge clk50) begin
	if (rst_n) begin
		clk25 <= 1'b0;
		x <= 10'b0;
		y <= 10'b0;
	end 
	else begin
		clk25 <= ~clk25;
		if (clk25 == 1'b1) begin

			if ((x & 7) == 7) begin 
				curr_char <= rd_data_r;
			end

			if (x < 10'd799) begin
				x <= x + 1'b1;
			end 
			else begin
				x <= 10'b0;
				if (y < 10'd524) begin
					y <= y + 1'b1;
				end 
				else begin
					y <= 10'b0;
				end
			end
		end 
	end

	
	if (valid) begin
		r <= pixels[7 - (x & 7)] ? !curr_char[6+8] : curr_char[2+8];
		g <= pixels[7 - (x & 7)] ? !curr_char[5+8] : curr_char[1+8];
		b <= pixels[7 - (x & 7)] ? !curr_char[4+8] : curr_char[0+8];
	end 
	else begin
		// blanking -> no pixels
		r <= 1'b0;
		g <= 1'b0;
		b <= 1'b0;
	end	 	
	
end

initial begin
	clk50 <= 1'b0;
	clk25 <= 1'b0;
	x <= 10'b0;
	y <= 10'b0;
	state <= INIT;
end

endmodule
